# CSS

CSS - это "язык" стилей (но полноценным языком он не считается). Он используется для нашего фронтенда - для оформления веб-страниц и придания 
им визуального стиля. Он идет в связке с HTML, определяет как HTML-элементы должны отражаться на экране (цвета, шрифты, расположение и т.д.).

В целом интуитивно понятно, как все устроено, но нужно понимать определенную логику их связи, в которой муторно разбираться.

Для подключения в html нашего css файла необходимо указать ссылку на него:

```
<link rel="stylesheet" href="/css/style.css">
```

Нельзя забывать про связь с нашим кодом в main.go файле:

```
http.Handle("/css/", http.StripPrefix("/css/", http.FileServer(http.Dir("css"))))
```
Шрифты можно найти:
[Тут](https://fonts.google.com/)

Подключаем их ссылкой в html и css

Одна из основных концепций - селекторы. Они указывают на какие HTML-элементы будут применяться стили:
body {
    селектор для тела
}
.checkbox {
    селектор для класса под названием "checkbox"
}
#standard {
    селектор для определенного ID
}

Внутри селекторов находятся свойства, они определяют конкретные аспекты внешнего вида элементов (будь то цвет, положение, размер и тд). И естесственно, 
они имеют значения:
h1 {
    color: #999; - тут мы в качестве свойства задаем цвет тексту заголовка (все значения обязательно заканчиваются ; )
}

Еще один момент, который ты должен учитывать - порядок объявления (каскадность), последнее объявление имеет приоритет в случае одинаковой важности и 
специфичности. Подробнее можешь погуглить.

# Docker

Немного поговорим о том что это такое и зачем он нужен.

Представь, что мы разрабатываем приложение (веб), которое состоит из многих элементов, которые написанны на разных языках (те в свою очередь 
используют разные библиотеки) - все это в сумме имеет разные зависимости (компиляторы и тд). Помимо того, необходимо все языки установить для нашего приложения, 
так же для поддержки приложения придется выпускать новые версии, при миграции на другой сервер, придется переносить всю среду и заново выполнять шаги установки (не 
забываем про новые версии, которые могут оказаться несовместимы с нашим старым окружением, от чего могут возникнуть ошибки).

Решать это вручную, как делали это когда-то - неоправданно трудоемко и сложно, поэтому когда-то эта проблема была решена созданием виртуальных машин, т.е. 
запуск в изолированной среде (требующая большого количества ресурсов), а позже пришли к контейнеризации. Виртуализация остается актуальной для множества задач 
(напр: тестирование), но например в контексте веб разработки технология контейнеризации определенно выигрывает. 

Контейнеры запускаются на основе образов (как и виртуальные машины), что решает проблему управлением зависимостями - один раз описываем образ, устанавливаем 
все необходимые зависимости, выполняем сборку и тд. Сами контейнеры по сути процессы, основное их преимущество от ВМ в том, что они легковесные, и запускают 
процесс не поверх нашей хостовой ОС (устанавливая другую ОС), а используя нашу хостовую ОС (ядро) и каждый запущенный контейнер делит ее.

Как работает сам Docker?

В первую очередь нам необходимо скачать образы (языков, ОС и тд) [Тут](https://hub.docker.com/)

После этого мы создаем Dockerfile, в котором уже будем описывать свой образ, который может включать в себя другие образы, если это необходимо. В этой файле 
мы описываем сборку и необходимую логику.

FROM - тут мы берем за основу уже существующий образ
RUN - выполняет команды во время сборки образа
COPY/ADD - копируют файлы и директории из нашей исходной директории в образ
WORKDIR - устанавливает рабочий каталог для последующих команд
EXPOSE - определяет порт, кот. контейнер будет прослушивать во время выполнения
CMD/ENTRYPOINT - задают команду, кот. будет выполнена при запуске контейнера
ARG - определяет переменные, кот. могут быть переданы при сборке образа
LABEL - добавляет мета-данные к образу в виде: ключ-значение

для сборки выполняем команду: docker build -t <imageName> .

На основе образа мы запускаем контейнер.

Для запуска контейнера: docker run -p 8080:8080 <imageName>
Для просмотра образов: docker images
Для просмотра всех контейнеров, включая не работающие: docker ps -a

Прежде чем удалить контейнер, необходимо остановить его: docker stop <containerID/name>
Удалить контейнер или образ: docker rm <containerID/imageID>
Образ можно удалить и так: docker image rm <ID/Name>
Принудительное удаление контейнера вместе с его остановкой: docker rm -f <containerID>
